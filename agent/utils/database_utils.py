import tinydb
from typing import List, Dict, Any


def get_schema_from_db(db: tinydb.TinyDB) -> Dict[str, Dict[str, set]]:
    """
    Extracts the schema from a TinyDB database.

    This function analyzes all records in the database to infer the schema.
    It identifies unique keys and their associated data types.  It also identifies if the keys are options and stores them.

    Args:
        db (tinydb.TinyDB): The TinyDB database instance.

    Returns:
        Dict[str, Dict[str, set]]: A dictionary representing the schema.
        The keys of the dictionary are the column names in the database.
        The values are dictionaries with keys "data_type" (a set of Python types found in that column)
        and "options" (a set of unique values if the column is deemed to be an option).
    """
    schema_options = ["tool_id", "data_type", "user_id"]
    schema = {}
    for record in db.all():
        for key, value in record.items():
            if key not in schema:
                if key in schema_options:
                    schema[key] = {"data_type": set(), "options": set()}
                else:
                    schema[key] = {"data_type": set()}
            if key in schema_options:
                schema[key]["data_type"].add(type(value))
                schema[key]["options"].add(value)
            else:
                schema[key]["data_type"].add(type(value))
    return schema


def run_generated_query(db: tinydb.TinyDB, query_string: str) -> List[Dict[str, Any]]:
    """
    Executes a TinyDB query generated as a string.

    This function takes a TinyDB database and a query string as input.
    It attempts to execute the query string against the database using `eval`.
    It handles potential errors during query execution and returns either the query results or an error message.

    Args:
        db (tinydb.TinyDB): The TinyDB database instance.
        query_string (str): The query string generated by the LLM.

    Returns:
        List[Dict[str, Any]]: The result of the query. Returns an empty list if there is an error.
    """
    try:
        # Provide the necessary context for eval: the tinydb module and the Query class
        operation = query_string.split("(")[0].split(".")[1]
        if operation not in ["search"]:
            results = []

        if operation == "search":
            query_string = query_string.replace("db.search", "")
            query = eval(query_string, {"tinydb": tinydb})
            results = db.search(query)
    except Exception as e:
        print(f"Error executing query: {e}")
        results = []

    return results


def convert_database_entries_to_conversation(database_entries: List[Dict[str, Any]]) -> str:
    """
    Converts a list of database entries into a formatted conversation string.

    This function processes a list of dictionaries, where each dictionary represents a database entry
    containing information about a turn in a conversation.  It formats these entries into a human-readable
    conversation string, including sender information (user, assistant, or tool) and the associated data.

    Args:
        database_entries (List[Dict[str, Any]]): A list of dictionaries, where each dictionary represents a database entry.
                                                 Each entry is expected to have keys like "timestamp", "tool_id", "data_type", and "data".

    Returns:
        str: A formatted conversation string.
    """
    conversation = {}
    for entry in database_entries:
        timestamp = entry["timestamp"]
        if not entry["tool_id"]:
            if entry["data_type"] == "user_input_text":
                sender = "user"
            else:
                sender = "assistant"
        else:
            if entry["data_type"] in ["input", "output"]:
                sender = "tool ({}, {})".format(entry["tool_id"], entry["data_type"])

            else:
                sender = "unknown"

        if entry["data_type"] not in ["image", "metadata"]:
            if (entry["data_type"] == "output") and (
                entry["tool_id"] == "query_conversation_logs"
            ):
                return_data = "The tool returned conversation logs related to the user's question, which have been removed for brevity"
            else:
                return_data = entry["data"]
            conversation[timestamp] = "{}: {}\n\n".format(sender, return_data)

    conversation_str = ""
    for k, v in sorted(conversation.items()):
        conversation_str += "({}) {}".format(k, v)

    return conversation_str
